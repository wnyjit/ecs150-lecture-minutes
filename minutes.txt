XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX OS OVERVIEW XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

wvwvwvwvwvwvwvwwvwvwvwvw OS Introduction wvwvwvwvwvwvwvwwvwvwvwvw
what is an os? a bit of history - 0
	microsoft lawswuit - 0
	
	clear definition. sits between hardware and applications - 2

what is a computer? - 3
	types of computers. desktop, server, IoT, car - 3

components of computer - 4
	cpu, interrupt controller, timer, memory, uart controller, hdd/sdd controller - 4
	general purpose computing, intel laptop chipset example - 6
	embedded computing, smartphone chipset - 7

hardware components - 8
	processor / cpu - 8
	memory - 10
		cpu registers, cpu cache, RAM/main, 2nd level - 11
	IO devices - 14
		device controller - 14
		memory mapped access, port mapped access - 15
	bus / interconnect - 17
		cache bus, memory bus, backside, frontside  - 18

OS Roles - 19
	Referee: resource allocation, isolation, communication - 19
	Illusionist: resource virtualization - 23 
	Glue: common services, provides hardware abstraction - 25

OS design principles - 27
	Reliability - 27
	Availability - 30
	Security, Privacy - 32
	Portablity - 34
	Performance - 37
		overhead - 37
		fairness - 38
		latency & throughput. ferrari vs truck - 40
		predictability - 41

OS history - 43
	1950: punch cards, batch systems - 43
		no OS at the time since it was only one application at a time - 46
	1960: integrated circuits, mainframe computers, IBM - 48
		IBM OS, multics OS - 49
		personal computers, unix posix BSD - 50
	1980: hardware is cheap. moores law - 53
		"six seven" - 53
	future: end of moore's, size, heterogeneity - 54
		3d stacking - 55
		size - 56
		heterogeneity - 57
wvwvwvwvwvwvwvwwvwvwvwvw OS Introduction wvwvwvwvwvwvwvwwvwvwvwvw

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

wvwvwvwvwvwvwvwwvwvwvwvw System Calls 1 wvwvwvwvwvwvwvwwvwvwvwvw
C program example #1, executable detector - 0
	explaining code - 0
	walking through with example input - 5

	"where do these functions come from?", C standard libary - 8

categories of functions - 13
	no priveleges required: memset - 15
	always need OS priveleges: file operations - 17
		"we need to call the OS" syscall - 20
			it may be different depending on OS and/or processor - 22
	sometimes needs OS priveleges: print - 23
		buffer flushing example - 23

user -> syscall -> OS kernel dynamics - 28
	syscall is OS api - 31

types of syscalls - 32
	process management - 33
		process definition vs program definition - 33
		PCB process control block - 37
		
		syscalls for process creation, execution, termination, identification - 38

		process creation - 40
			fork(), process cloning - 40	
				how to tell the original from the clone? - 45
					fork return value: PID of parent - 47
				order of fork execution is random - 51		
wvwvwvwvwvwvwvwwvwvwvwvw System Calls 1 wvwvwvwvwvwvwvwwvwvwvwvw

wvwvwvwvwvwvwvwwvwvwvwvw System Calls 2 wvwvwvwvwvwvwvwwvwvwvwvw
previous lecture recap - 0
	categories of functions based on privileges - 0
	What is a process?, PCB process control block - 2
	fork() - 2

continuing types of syscalls - 3
	process management continued - 3
		exec(), execute another program - 4
			variations of exec() - 6
			exec() never returns if it succeeds - 9
			PID doesnt change, everything else does - 10

		exit(), terminate the current process - 12
			return values - 14
			collecting return values - 17

		wait() waitpid(), make parent wait for child - 18
			WEXITSTATUS - 22

		combining fork() exec() wait() - 26
			system() - 28
			this is a shell - 30

		getpid() getppid(), process ID parent process ID - 32
			unix init - 33
			"this PID is the shell's!" - 36

	Files and directories - 37
		tree structure - 37
		VFS virtual file system
		
		open(), read() - 40
		lseek() - 43
		fd file descriptor - 44 
			open() always returns the first available fd - 47
wvwvwvwvwvwvwvwwvwvwvwvw System Calls 2 wvwvwvwvwvwvwvwwvwvwvwvw

wvwvwvwvwvwvwvwwvwvwvwvw System Calls 3 wvwvwvwvwvwvwvwwvwvwvwvw
prervious lecture recap - 0
	fork() exec() wait() is the core of a shell - 0
	fd file descriptor - 0

continue types of syscalls - 1
	files and directories - 1
		first 3 are prefilled STDIN STDOUT STDERR - 2
		fprintf() - 5
		fd redirections - 8
		dup2() - 11
			why use dup2() over open() - 17
		stat() fstat() - 19
		getcwd() chdir() opendir() closedir() readdir() - 20

	pipes - 24
		IPC interprocess communication channel - 24
				*LOUD.mp3* - 27
		the pipe is a buffer - 29
		it works with file descriptors - 31
		processes in the pipe are synchronized - 32
		pipe() - 33
			example program 1 - 33
			example program 2 - 36
				"this is how you pipe in a shell" - 44

	signals - 45
		SIGSEGV SIGINT SIGKILL SIGCHLD SIGSTOP SIGCONT - 46
			SIGSTOP and SIGKILL cannot be ignored - 50
		raise() kill() alarm() setitimer() sigprocmask() sigpending() sigaction() pause() - 50
			example program 1 - 52
				"we will kill ourselves" - 52

	memory management - 54
		malloc() free() - 54
		mmap() - 56
wvwvwvwvwvwvwvwwvwvwvwvw System Calls 3 wvwvwvwvwvwvwvwwvwvwvwvw

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

wvwvwvwvwvwvwvwwvwvwvwvw OS Structure wvwvwvwvwvwvwvwwvwvwvwvw
overview, applications, libraries, user mode, kernel, portable layer, machine-dependent layer - 0

application layer - 1
	libraries - 2
		definitions - 2
		declerations - 3
			gcc auto-links you to the c library - 4
			static compilation vs dynamic compilation - 5

	the compilation process - 6
		CPP preprocessor, CC compiler, AS assembler, LD linker - 7

	the executable, two parts - 11
		directly from executable - 11
		created at runtime - 12

		why is data & code not combined into a single section - 13
		why is heap and stack seperated - 15

	LDD and the Loader - 17

	example code #1, static libraries, dynamic libraries, dynamically loaded libraries - 21
		dynamic libraries - 21
		static libraries - 23
		dynamically loaded libraries - 25

Kernel layer - 28
		porquet thinkpad user - 28
	portable parts of the OS - 30
	machine-dependent parts of the OS - 31

	OS interface layers: API, UAPI, HAL, ISA+ABI - 32
		API application programming interface - 33
		UAPI user API - 33
		HAL hardware abstraction layer - 34
		ISA istruction set architecure - 35
		ABI application binary interace - 35
				
	kernel structures - 36
				*KERNEL_STRUCTURE_loud.mp3* - 36
		monolithic kernel - 37			
		micro kernel - 39
		hybrid kernel - 45

	simplified linux internal structure - 46
wvwvwvwvwvwvwvwwvwvwvwvw OS Structure wvwvwvwvwvwvwvwwvwvwvwvw

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

wvwvwvwvwvwvwvwwvwvwvwvw Kernel Abstraction 1 wvwvwvwvwvwvwvwwvwvwvwvw
introduction to process abstraction - 0
	what is a process, source code, executable, program - 1
		.text, .data, heap, stack - 2
		stack pointer, program counter - 4
	the kernel is a process itself - 4
	processes are bigger than programs - 6

	protection - 7
	
	in-depth process definition - 10

protected execution, process run with limited rights - 11
	limited privilege execution, interpreted execution, native execution - 14
	
dual mode operation - 18
	kernel mode, user mode - 19
		protection rings - 22
		hardware support - 24
			privileged instructions - 24
			memory protection - 27
			timer interrupts - 28
			mode switch - 29
	5 stage pipeline - 31
		status register - 35
wvwvwvwvwvwvwvwwvwvwvwvw Kernel Abstraction 1 wvwvwvwvwvwvwvwwvwvwvwvw

wvwvwvwvwvwvwvwwvwvwvwvw Kernel Abstraction 2 wvwvwvwvwvwvwvwwvwvwvwvw
previous lecture recap - 0

privileged instruction, ISA instruction set architecutre - 4
		CLI clear interrupt flag - 5
		mips manual- 8
		
memory protection - 11
	virtual memory solves the shortcomings of memory protection - 17
	
computer boot sequence - 19
		*you_just_bought_a_new_car_LOUD.mp3* - 23
		
timer interrupts - 25
	tick, jiffy - 27
	
mode switching - 31
	user to kernel switching, for only 3 reasons - 31
		exceptions - 32
			synchronous event - 35
		interrupts - 36
			polling - 38
					*YOU_TELL_ME_loud.mp3* - 39
			asynchronous event - 39
		syscall - 40
	kernel to use switching, for 4 reasons - 43
		returning from an interrupt or syscall - 43
		process context switch - 44
		new process start - 45
		signal handling - 48
wvwvwvwvwvwvwvwwvwvwvwvw Kernel Abstraction 2 wvwvwvwvwvwvwvwwvwvwvwvw

wvwvwvwvwvwvwvwwvwvwvwvw Kernel Abstraction 3 wvwvwvwvwvwvwvwwvwvwvwvw
previous lecture recap - 0
	reasons for switching modes, user to kernel - 0
	reasons for switching modes, kernel to user - 2
	
how to perform mode switching - 3 
		*THE_MACHINE_loud.mp3* - 5
	requirements for safe and efficient switching - 5
		atomic transfer of control - 5
		exception vector - 6
		transparent, restartable execution - 6
		
		atomic transfer of control in depth - 7
			the switch must not be interrupted - 9
			
			steps of mode switching for user to kernel - 11
				"we assume the kernel may not be interrupted" - 14
			steps of mode switching for kernel to user - 14
			
		exception vector in depth - 16
			software managed - 21
			hardware managed - 22
			
		transparent & restartable execution - 23
			software managed - 23
			hardware managed - 27
			
kernel stack, PC, SP, register file, context saving for 1 process - 28
	"why do we need a specific kernel stack?" - 34
	context saving for 2 processes - 38
wvwvwvwvwvwvwvwwvwvwvwvw Kernel Abstraction 3 wvwvwvwvwvwvwvwwvwvwvwvw


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX OS OVERVIEW XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX






XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX PROCESS MANAGEMENT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

wvwvwvwvwvwvwvwwvwvwvwvw Process Scheduling 1 wvwvwvwvwvwvwvwwvwvwvwvw
process definition recap - 0

process characteristics - 2
	address space - 2
		.code .data, heap, stack - 4
		malloc() - 7
		fork() - 9
				*PRINTF()_loud.mp3* - 14
	environment, PCB process control block - 18
	execution flow - 19
		sequential order - 19
			signals break sequential - 21
				
scheduling concepts - 22
	CPU burst, IO burst - 25
	CPU bound process, IO bound process, mix bound process - 28
	
	multitasking - 32
		cooperative - 33
		preemptive - 36
		
	process lifecycle diagram, process states, ready state, running state, blocked state, zombie state  - 38
		zombie process - 40
			what happens if parent dies before child - 42
					lol - 45
				SIGHUP, reparenting - 47
wvwvwvwvwvwvwvwwvwvwvwvw Process Scheduling 1 wvwvwvwvwvwvwvwwvwvwvwvw

wvwvwvwvwvwvwvwwvwvwvwvw Process Scheduling 2 wvwvwvwvwvwvwvwwvwvwvwvw
previous lecture recap - 0

scheduling vocabulary - 8
	task & process - 8
	submission time / arrival time - 10
	exit time - 11
	turnaround time / turnout time - 11
	response time - 12
	waiting time - 14
	
scheduling algorithms - 16
	FCFS first come first serve / FIFO first in first out - 16
		convoy effect - 20
	SJF shortest job first - 21
		"its impossible in real life" - 22
	Preemptive SJF / SRTF shortest remaining time first - 24
		starvation - 25
		
	optimizing for turnaround time vs response time - 27
		SJF example - 29
		
	RR round robin - 30
		time slice - 31

	multi level queue scheduling - 36
	multi level feedback queue - 40
wvwvwvwvwvwvwvwwvwvwvwvw Process Scheduling 2 wvwvwvwvwvwvwvwwvwvwvwvw

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

wvwvwvwvwvwvwvwwvwvwvwvw Concurrency and Threads 1 wvwvwvwvwvwvwvwwvwvwvwvw
introduction, concurrency vs sequential - 0
	kitchen example - 1
	concurrency is NOT parallelism - 2

	process concurrency - 3
		the gcc compiler can compile things in parallel - 5

types of concurrency - 7
	sequential execution - 7
	CPU virtualization - 7
	IO concurrency - 9
	CPU parallelism - 10

speedup, company example - 12
	ideal / linear - 13
	sublinear, the company starts to slow - 14
	superlinear, cooking example - 16

processes are slow to fork() and context switch - 19

threads introduction - 20
	example - 22
	rationale for threads - 25
		the real world is concurrent - 25
		threading is more responsive - 28
		threading makes for faster execution - 28
		no need for IPC - 29

	example of multi-threaded applications - 30
		web server - 30
				*ehm_loud.mp3* - 33
		array computation - 33
			parallel computation is not possible by forking - 36

	thread characteristics - 38
		execution context - 38
		process environment - 39
		address space - 41
			threads share heap and global vars but not stack - 41
		TCB thread control block, PCB process control block - 46

		differences between threads and processes - 48
wvwvwvwvwvwvwvwwvwvwvwvw Concurrency and Threads 1 wvwvwvwvwvwvwvwwvwvwvwvw

wvwvwvwvwvwvwvwwvwvwvwvw Concurrency and Threads 2 wvwvwvwvwvwvwvwwvwvwvwvw
previous lecture recap - 0
	concurrent definition, sequential definition - 0
	concurrency isnt parallelism - 1
	threads vs processes - 3

thread implementation - 4
	thread API - 4

kernel level threads / one to one model - 8
	non-multi-threaded example - 9
	mutlithreaded example - 11
	context switching procedure - 12
user level threads / many to one model - 14
	thread library - 14
	multi-threading example - 15
	context switching procedure - 16
		"but if one thread blocks on IO..." - 19
direct comparison between kernel level threads and user level threads - 20
	go vs java - 23
		
types of threads - 24
	single thread process - 24
	multi-threaded userlevel - 24
	multi-threaded kernel level - 25
	in-kernel threads - 25
		idle thread, thread migration, OOM reaper, disk writeback - 25
		
thread scheduling - 27
	cooperative - 27
	preemptive - 29
	
POSIX threads - 31

thread issues - 32
	forking inside a thread function - 32
	data sharing, race condition - 36
	certain signals can identify threads but other signals cant - 39
	libraries, strtok(), global variables, errno - 42
		reentrant function - 48
wvwvwvwvwvwvwvwwvwvwvwvw Concurrency and Threads 2 wvwvwvwvwvwvwvwwvwvwvwvw

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX PROCESS MANAGEMENT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX






XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX SYNCHRONIZATION XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

wvwvwvwvwvwvwvwwvwvwvwvw Synchronization 1 wvwvwvwvwvwvwvwwvwvwvwvw
previous lecture recap - 0
	two types of thread data sharing - 1
		independent sharing - 1
		cooperative sharing - 2
				*ISSUE_loud.mp3* - 3
				
concurrency issues, thread scheduling - 3
	indeterministic interleavings - 5
		atomic statements & example - 6
				*ORIGINALLY_loud.mp3* - 10
	instruction reordering - 13
		compiler instruction reodering - 13
		hardware instruction reordering - 15
		multi-word operations - 15
		
race conditions - 18
	race conditions kill people - 20

roomate milk example - 22
	properties of correctness: safety, liveness - 24
	solution attempt #1 - 25
		why it doesnt work - 28
	solution attempt #2 - 30
		why it doesnt work, safe but not live - 32
	solution attempt #3 - 34
		why it works, safe & live, but confusing - 35
			busy waiting - 40
	peterson's algorithm - 41
	
extra vocab - 42
	critical section - 42
	safety, liveness, bounded waiting, failure atomicity - 43
	mutual exclusion - 44
	
back to roomate milk example - 45
wvwvwvwvwvwvwvwwvwvwvwvw Synchronization 1 wvwvwvwvwvwvwvwwvwvwvwvw

wvwvwvwvwvwvwvwwvwvwvwvw Synchronization 2 wvwvwvwvwvwvwvwwvwvwvwvw
previous lecture recap - 0
		*CONCURRENTLY_loud.mp3* - 0
	milk example vocab - 1
	safety and liveness - 3
	mutual exclusion - 3

	
synchronization primitive - 4
	lock - 4
		implementing locks, avoiding preemption - 8
		problem with locks - 11
		multiprocessor spinlocks, test and set, hardware support for parallel locks - 14
			spinlock implementation - 20	
			going back to roomate milk example - 24
			spinlocks waste CPU - 25
				it has low latency - 27
			cheap busy waiting, "lowk might be worse" - 27
			blocking spinlock - 31
			
	semaphore, generalized lock - 32
		semaphore API, down() p(), up() v() - 35
		sem implementation, protect sem manipulation with locks - 38
		binary semaphore - 39
			mutex vs sem - 41
		counted semaphore - 42
wvwvwvwvwvwvwvwwvwvwvwvw Synchronization 2 wvwvwvwvwvwvwvwwvwvwvwvw

wvwvwvwvwvwvwvwwvwvwvwvw Synchronization 3 wvwvwvwvwvwvwvwwvwvwvwvw
previous lecture recap - 0
	locks - 0
	disabling interrupts is impractical for users - 1
	spinlocks, test and set - 1
	semaphore, down() up() - 4
	binary sem - 6
	counted sem - 7
	
classic synchronization examples - 8
	producers consumers problem - 9
		code solution #1 - 12
			two main issues - 16
		code solution #2, binary sem - 18
		code solution #3, counted sem - 20
		
	readers writers problem - 25
			*LOUD.mp3* - 26
		code solution #1 - 29
		code solution #2, writer can write only when all readers are gone - 34
		code solution #3, adding new lock - 36
			writers can starve - 38
			
closing remarks on semaphores - 39
	monitors - 43
	
synchronization barriers - 44

synchronization big picture - 46
wvwvwvwvwvwvwvwwvwvwvwvw Synchronization 3 wvwvwvwvwvwvwvwwvwvwvwvw

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

wvwvwvwvwvwvwvwwvwvwvwvw Deadlocks 1 wvwvwvwvwvwvwvwwvwvwvwvw
introduction - 0
	example code - 1
	dining philosophers - 6
	starvation - 11
	deadlock - 12
	
resource allocation graph - 14
	deadlocks are cycles - 17
	
deadlock 4 conditions (all 4 must be met) - 17
	mutual exclusion / bounded resources - 18
	hold and wait - 20
	no preemption - 21
	circular wait - 22
	
deadlock 4 strategies - 23
	ostrich algorithm, the nuclear option - 26
	detection and recovery - 30
		detection using the resource allocaion graph - 32
		recovery by 3 methods - 33
			kill task - 33
			rollback task - 34
			resource preemption - 36
		cycle detection algorithm - 37
				*SIX_loud.mp3* - 40
wvwvwvwvwvwvwvwwvwvwvwvw Deadlocks 1 wvwvwvwvwvwvwvwwvwvwvwvw

wvwvwvwvwvwvwvwwvwvwvwvw Deadlocks 2 wvwvwvwvwvwvwvwwvwvwvwvw
previous lecture recap - 0
	starvation, deadlock - 0
	4 deadlock conditions, mutual exclusion, hold & wait, no preemption, circular wait - 3
	4 deadlock strategies, ostrich, detection & reccovery, dynamic avoidance, prevention - 5
	
continuing 4 deadlock strategies - 8
	dynamic avoidance - 8
		safe state, unsafe state - 9
		banker's algorithm - 12
			example #1 - 14
			example #2 - 22
	prevention - 27
		more resources & virtulization - 29
		lock free resources - 32
		no preemption - 37
		preventing circular waits by ordering - 40

livelock - 42
deadlock strategies in real life - 45
	locks free data structures - 48
		lock free stack - 51
	transactional memory - 1.00
wvwvwvwvwvwvwvwwvwvwvwvw Deadlocks 2 wvwvwvwvwvwvwvwwvwvwvwvw

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX SYNCHRONIZATION XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX






XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX STORAGE XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

wvwvwvwvwvwvwvwwvwvwvwvw Storage 1 wvwvwvwvwvwvwvwwvwvwvwvw
introduction - 0
	memory heirarchy - 0
		volitile memory - 0
		secondary storage - 4
	
memory technology - 8
	SRAM static random access memory: technology behind caches - 8
	DRAM dynamic random acess memory - 10
		"dynamic" capacitors leak so you must refresh it - 10
	HDD hard disk drive / magnetic disk - 12
	SSD solid state drive / flash - 14
	
dive into magnetic disks - 16
	anatomy of disk - 16
		platters - 16
		surfaces, both sides of platter - 17
		spindle & motor - 18
		head - 18
		arm & arm assembly - 19
		tracks & sectors - 20
		cylinder - 21
	history - 21
	tracks - 22
		sectoring: uniform sectoring & ZBR zone bit recording - 24
		velocity: CLV constant linear velocity & CAV constant angular velocity - 25
	sector - 27
		header, data, trailer / ECC error correcting codes - 27
		addressing: CHS cylinder head sector, LBA logical block address - 29
	track skewing - 30
	corrupted sectors - 33
		solution # 1, spare sectors - 33
		solution #2, slip sparing - 35
	disk operation - 35
		1. disk moves arm to correct cylinder (seek time + settle time) - 35
		2. wait for sector to appear on head (rotation time) - 36
		3. read/write sector as it spins (transfer time) - 37
		access time = seek time + rotation time + transfer time - 37
	disk performance - 38
		seek time - 38
		rotation time - 41
		transfer time - 42
		example performance toshiba hdd - 44
			seek time is longer for writing than reading - 45
			500 random reads - 46
			500 sequential reads - 50
wvwvwvwvwvwvwvwwvwvwvwvw Storage 1 wvwvwvwvwvwvwvwwvwvwvwvw

wvwvwvwvwvwvwvwwvwvwvwvw Storage 2 wvwvwvwvwvwvwvwwvwvwvwvw
previous lecture recap - 0
	sram dram - 0
	secondary storage, magnetic disk, flash memory - 1
		access time = seek time + rotation time + transfer time - 2
		random vs sequential reads - 3
		
magnetic disk scheduling - 4
	fcfs first come first serve, fifo - 6
	sstf shortest seek time first - 9
	scan, elevator algorithm - 12
	c-scan, circular elevator algorithm - 15
	c-look - 17
	r-cscan - 17
	f-scan - 19
	n-scan - 21
	"there is no best..." - 22
	
example performance using c-look - 23
		*porquet_face.mp4* - 28
			
flash storage - 29
	general characteristics - 29
	NOR vs NAND - 30
	"heres how it works" - 31
		transistors, control, drain, source, floating gate, threshold - 31
		how to read information - 36
	single level vs mutli level - 38
	organization: pages, blocks, planes, di - 39
	read page, write page, erase block, page unit - 40
		you can only write to empty page - 41
		you can only reset page if you reset entire block - 42
		example page writing - 43
	flash translation layer / write remapping - 46
	durability issues - 49
		solutions - 50
	example performance intel ssd - 54
		"we can just use fifo!" - 55
wvwvwvwvwvwvwvwwvwvwvwvw Storage 2 wvwvwvwvwvwvwvwwvwvwvwvw

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

wvwvwvwvwvwvwvwwvwvwvwvw FS Abstraction wvwvwvwvwvwvwvwwvwvwvwvw
introduction - 0
	requirements expected of mass storage - 0
	filesystem - 3
	
filesystem concepts - 5
	files - 5
	metadata - 6
	data - 6
	directory, "a file doesnt know its own name" - 7
	conventions, length, extension, case sensitivity - 9
		magic number at start of file to identify its format - 12
		shebang #! - 14
	path, absolute path, relative path, current directory, parent directory - 15
	hard link - 17
		directed graph - 19
		cycles are bad - 20
		hardlinks are forbidden on directories, DAG directed acyclic graph - 22
	soft link / symobolic links / symlinks - 24
	volume - 27
	partitions, MBR master boot record, GPT - 30
	drive letter assignment (windows) - 32
	VFS virtual file system / unified file system / mounting (unix) - 34
		fstab - 37
	software layers - 38
	typical filesystem API - 44
		create(), link() unlink() - 44
			example - 46
		open() close() - 47
		read() write() seek() mmap() munmap() - 53
		
wvwvwvwvwvwvwvwwvwvwvwvw FS Abstraction wvwvwvwvwvwvwvwwvwvwvwvw

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

wvwvwvwvwvwvwvwwvwvwvwvw FS Implementation 1 wvwvwvwvwvwvwvwwvwvwvwvw
introduction - 0
	filesystem - 0
	directory - 1
	file 2
	
filesystem 4 objectives - 3
	performance - 3
	flexibility - 4
	persistance - 5
	reliability - 6
	
filesystem design considerations - 7
	workload - 7
	file acess and IO transfer + chrome example - 9
	file access pattern and usage - 12
	block vs disk sectors - 14
		big block size - 16
		small block size - 18
	review: small files vs large files - 19

implementation considerations - 22
		*nuke_goes_off_outside.mp4* - 22
	data structures for directories, index structure, free space map - 24
	
directory implementation, "its just a file" - 26
	opendir() readdir() - 27
	hierarchy - 28
		flat hierarchy - 28
		multi user flat hierarchy - 28
		multi user multi level hierarchy - 29
	layout - 30
		linear layout - 30
		list layout - 32
		tree layout - 34
	index structure - 36
		5 goals - 36
		contiguous allocation - 38
				fragmentation explained - 43
					internal fragmentation - 43
					external fragmentation - 44
		linked list allocation - 45
wvwvwvwvwvwvwvwwvwvwvwvw FS Implementation 1 wvwvwvwvwvwvwvwwvwvwvwvw

wvwvwvwvwvwvwvwwvwvwvwvw FS Implementation 2 wvwvwvwvwvwvwvwwvwvwvwvw
previous lecture recap - 0
	directory implementation - 2
	index structures - 3

continuing index structures - 6
	dirtect allocation - 6
	indexed allocation - 9
	linked index blocks - 13 
	multi level index blocks - 17
	
MS FAT microsoft file allocation table - 21
	introduction - 22
	FAT file allocation table - 25
	example - 26
	next fit algorithm - 32
	directory structure - 34
	FAT doesnt allow hard links - 37
	layout on disk - 39
	locality issues - 40
		defragmentation to fix - 41
	conclusion - 42
		cons - 43
wvwvwvwvwvwvwvwwvwvwvwvw FS Implementation 2 wvwvwvwvwvwvwvwwvwvwvwvw

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX STORAGE XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX










