XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX OS OVERVIEW XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

wvwvwvwvwvwvwvwwvwvwvwvw OS Introduction wvwvwvwvwvwvwvwwvwvwvwvw
what is an os? a bit of history - 0
	microsoft lawswuit - 0
	
	clear definition. sits between hardware and applications - 2

what is a computer? - 3
	types of computers. desktop, server, IoT, car - 3

components of computer - 4
	cpu, interrupt controller, timer, memory, uart controller, hdd/sdd controller - 4
	general purpose computing, intel laptop chipset example - 6
	embedded computing, smartphone chipset - 7

hardware components - 8
	processor / cpu - 8
	memory - 10
		cpu registers, cpu cache, RAM/main, 2nd level - 11
	IO devices - 14
		device controller - 14
		memory mapped access, port mapped access - 15
	bus / interconnect - 17
		cache bus, memory bus, backside, frontside  - 18

OS Roles - 19
	Referee: resource allocation, isolation, communication - 19
	Illusionist: resource virtualization - 23 
	Glue: common services, provides hardware abstraction - 25

OS design principles - 27
	Reliability - 27
	Availability - 30
	Security, Privacy - 32
	Portablity - 34
	Performance - 37
		overhead - 37
		fairness - 38
		latency & throughput. ferrari vs truck - 40
		predictability - 41

OS history - 43
	1950: punch cards, batch systems - 43
		no OS at the time since it was only one application at a time - 46
	1960: integrated circuits, mainframe computers, IBM - 48
		IBM OS, multics OS - 49
		personal computers, unix posix BSD - 50
	1980: hardware is cheap. moores law - 53
		"six seven" - 53
	future: end of moore's, size, heterogeneity - 54
		3d stacking - 55
		size - 56
		heterogeneity - 57
wvwvwvwvwvwvwvwwvwvwvwvw OS Introduction wvwvwvwvwvwvwvwwvwvwvwvw

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

wvwvwvwvwvwvwvwwvwvwvwvw System Calls 1 wvwvwvwvwvwvwvwwvwvwvwvw
C program example #1, executable detector - 0
	explaining code - 0
	walking through with example input - 5

	"where do these functions come from?", C standard libary - 8

categories of functions - 13
	no priveleges required: memset - 15
	always need OS priveleges: file operations - 17
		"we need to call the OS" syscall - 20
			it may be different depending on OS and/or processor - 22
	sometimes needs OS priveleges: print - 23
		buffer flushing example - 23

user -> syscall -> OS kernel dynamics - 28
	syscall is OS api - 31

types of syscalls - 32
	process management - 33
		process definition vs program definition - 33
		PCB process control block - 37
		
		syscalls for process creation, execution, termination, identification - 38

		process creation - 40
			fork(), process cloning - 40	
				how to tell the original from the clone? - 45
					fork return value: PID of parent - 47
				order of fork execution is random - 51		
wvwvwvwvwvwvwvwwvwvwvwvw System Calls 1 wvwvwvwvwvwvwvwwvwvwvwvw

wvwvwvwvwvwvwvwwvwvwvwvw System Calls 2 wvwvwvwvwvwvwvwwvwvwvwvw
previous lecture recap - 0
	categories of functions based on privileges - 0
	What is a process?, PCB process control block - 2
	fork() - 2

continuing types of syscalls - 3
	process management continued - 3
		exec(), execute another program - 4
			variations of exec() - 6
			exec() never returns if it succeeds - 9
			PID doesnt change, everything else does - 10

		exit(), terminate the current process - 12
			return values - 14
			collecting return values - 17

		wait() waitpid(), make parent wait for child - 18
			WEXITSTATUS - 22

		combining fork() exec() wait() - 26
			system() - 28
			this is a shell - 30

		getpid() getppid(), process ID parent process ID - 32
			unix init - 33
			"this PID is the shell's!" - 36

	Files and directories - 37
		tree structure - 37
		VFS virtual file system
		
		open(), read() - 40
		lseek() - 43
		fd file descriptor - 44 
			open() always returns the first available fd - 47
wvwvwvwvwvwvwvwwvwvwvwvw System Calls 2 wvwvwvwvwvwvwvwwvwvwvwvw

wvwvwvwvwvwvwvwwvwvwvwvw System Calls 3 wvwvwvwvwvwvwvwwvwvwvwvw
prervious lecture recap - 0
	fork() exec() wait() is the core of a shell - 0
	fd file descriptor - 0

continue types of syscalls - 1
	files and directories - 1
		first 3 are prefilled STDIN STDOUT STDERR - 2
		fprintf() - 5
		fd redirections - 8
		dup2() - 11
			why use dup2() over open() - 17
		stat() fstat() - 19
		getcwd() chdir() opendir() closedir() readdir() - 20

	pipes - 24
		IPC interprocess communication channel - 24
				*LOUD.mp3* - 27
		the pipe is a buffer - 29
		it works with file descriptors - 31
		processes in the pipe are synchronized - 32
		pipe() - 33
			example program 1 - 33
			example program 2 - 36
				"this is how you pipe in a shell" - 44

	signals - 45
		SIGSEGV SIGINT SIGKILL SIGCHLD SIGSTOP SIGCONT - 46
			SIGSTOP and SIGKILL cannot be ignored - 50
		raise() kill() alarm() setitimer() sigprocmask() sigpending() sigaction() pause() - 50
			example program 1 - 52
				"we will kill ourselves" - 52

	memory management - 54
		malloc() free() - 54
		mmap() - 56
wvwvwvwvwvwvwvwwvwvwvwvw System Calls 3 wvwvwvwvwvwvwvwwvwvwvwvw

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

wvwvwvwvwvwvwvwwvwvwvwvw OS Structure wvwvwvwvwvwvwvwwvwvwvwvw
overview, applications, libraries, user mode, kernel, portable layer, machine-dependent layer - 0

application layer - 1
	libraries - 2
		definitions - 2
		declerations - 3
			gcc auto-links you to the c library - 4
			static compilation vs dynamic compilation - 5

	the compilation process - 6
		CPP preprocessor, CC compiler, AS assembler, LD linker - 7

	the executable, two parts - 11
		directly from executable - 11
		created at runtime - 12

		why is data & code not combined into a single section - 13
		why is heap and stack seperated - 15

	LDD and the Loader - 17

	example code #1, static libraries, dynamic libraries, dynamically loaded libraries - 21
		dynamic libraries - 21
		static libraries - 23
		dynamically loaded libraries - 25

Kernel layer - 28
		porquet thinkpad user - 28
	portable parts of the OS - 30
	machine-dependent parts of the OS - 31

	OS interface layers: API, UAPI, HAL, ISA+ABI - 32
		API application programming interface - 33
		UAPI user API - 33
		HAL hardware abstraction layer - 34
		ISA istruction set architecure - 35
		ABI application binary interace - 35
				
	kernel structures - 36
				*KERNEL_STRUCTURE_loud.mp3* - 36
		monolithic kernel - 37			
		micro kernel - 39
		hybrid kernel - 45

	simplified linux internal structure - 46
wvwvwvwvwvwvwvwwvwvwvwvw OS Structure wvwvwvwvwvwvwvwwvwvwvwvw

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

wvwvwvwvwvwvwvwwvwvwvwvw Kernel Abstraction 1 wvwvwvwvwvwvwvwwvwvwvwvw
introduction to process abstraction - 0
	what is a process, source code, executable, program - 1
		.text, .data, heap, stack - 2
		stack pointer, program counter - 4
	the kernel is a process itself - 4
	processes are bigger than programs - 6

	protection - 7
	
	in-depth process definition - 10

protected execution, process run with limited rights - 11
	limited privilege execution, interpreted execution, native execution - 14
	
dual mode operation - 18
	kernel mode, user mode - 19
		protection rings - 22
		hardware support - 24
			privileged instructions - 24
			memory protection - 27
			timer interrupts - 28
			mode switch - 29
	5 stage pipeline - 31
		status register - 35
wvwvwvwvwvwvwvwwvwvwvwvw Kernel Abstraction 1 wvwvwvwvwvwvwvwwvwvwvwvw

wvwvwvwvwvwvwvwwvwvwvwvw Kernel Abstraction 2 wvwvwvwvwvwvwvwwvwvwvwvw
previous lecture recap - 0

privileged instruction, ISA instruction set architecutre - 4
		CLI clear interrupt flag - 5
		mips manual- 8
		
memory protection - 11
	virtual memory solves the shortcomings of memory protection - 17
	
computer boot sequence - 19
		*you_just_bought_a_new_car_LOUD.mp3* - 23
		
timer interrupts - 25
	tick, jiffy - 27
	
mode switching - 31
	user to kernel switching, for only 3 reasons - 31
		exceptions - 32
			synchronous event - 35
		interrupts - 36
			polling - 38
					*YOU_TELL_ME_loud.mp3* - 39
			asynchronous event - 39
		syscall - 40
	kernel to use switching, for 4 reasons - 43
		returning from an interrupt or syscall - 43
		process context switch - 44
		new process start - 45
		signal handling - 48
wvwvwvwvwvwvwvwwvwvwvwvw Kernel Abstraction 2 wvwvwvwvwvwvwvwwvwvwvwvw

wvwvwvwvwvwvwvwwvwvwvwvw Kernel Abstraction 3 wvwvwvwvwvwvwvwwvwvwvwvw
previous lecture recap - 0
	reasons for switching modes, user to kernel - 0
	reasons for switching modes, kernel to user - 2
	
how to perform mode switching - 3 
		*THE_MACHINE_loud.mp3* - 5
	requirements for safe and efficient switching - 5
		atomic transfer of control - 5
		exception vector - 6
		transparent, restartable execution - 6
		
		atomic transfer of control in depth - 7
			the switch must not be interrupted - 9
			
			steps of mode switching for user to kernel - 11
				"we assume the kernel may not be interrupted" - 14
			steps of mode switching for kernel to user - 14
			
		exception vector in depth - 16
			software managed - 21
			hardware managed - 22
			
		transparent & restartable execution - 23
			software managed - 23
			hardware managed - 27
			
kernel stack, PC, SP, register file, context saving for 1 process - 28
	"why do we need a specific kernel stack?" - 34
	context saving for 2 processes - 38	
wvwvwvwvwvwvwvwwvwvwvwvw Kernel Abstraction 3 wvwvwvwvwvwvwvwwvwvwvwvw


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX OS OVERVIEW XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX






XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX PROCESS MANAGEMENT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

wvwvwvwvwvwvwvwwvwvwvwvw Process Scheduling 1 wvwvwvwvwvwvwvwwvwvwvwvw
process definition recap - 0

process characteristics - 2
	address space - 2
		.code .data, heap, stack - 4
		malloc() - 7
		fork() - 9
				*PRINTF()_loud.mp3* - 14
	environment, PCB process control block - 18
	execution flow - 19
		sequential order - 19
			signals break sequential - 21
				
scheduling concepts - 22
	CPU burst, IO burst - 25
	CPU bound process, IO bound process, mix bound process - 28
	
	multitasking - 32
		cooperative - 33
		preemptive - 36
		
	process lifecycle diagram - 38
		zombie process - 40
			what happens if parent dies before child - 42
					lol - 45
				SIGHUP, reparenting - 47
wvwvwvwvwvwvwvwwvwvwvwvw Process Scheduling 1 wvwvwvwvwvwvwvwwvwvwvwvw

wvwvwvwvwvwvwvwwvwvwvwvw Process Scheduling 2 wvwvwvwvwvwvwvwwvwvwvwvw
previous lecture recap - 0

scheduling vocabulary - 8
	task & process - 8
	submission time / arrival time - 10
	exit time - 11
	turnaround time / turnout time - 11
	response time - 12
	waiting time - 14
	
scheduling algorithms - 16
	FCFS first come first serve / FIFO first in first out - 16
		convoy effect - 20
	SJF shortest job first - 21
		"its impossible in real life" - 22
	Preemptive SJF / SRTF shortest remaining time first - 24
		starvation - 25
		
	optimizing for turnaround time vs response time - 27
		SJF example - 29
		
	RR round robin - 30
		time slice - 31

	multi level queue scheduling - 36
	multi level feedback queue - 40
wvwvwvwvwvwvwvwwvwvwvwvw Process Scheduling 2 wvwvwvwvwvwvwvwwvwvwvwvw

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

wvwvwvwvwvwvwvwwvwvwvwvw Concurrency and Threads 1 wvwvwvwvwvwvwvwwvwvwvwvw
introduction, concurrency vs sequential - 0
	kitchen example - 1
	concurrency is NOT parallelism - 2

	process concurrency - 3
		the gcc compiler can compile things in parallel - 5

types of concurrency - 7
	sequential execution - 7
	CPU virtualization - 7
	IO concurrency - 9
	CPU parallelism - 10

speedup, company example - 12
	ideal / linear - 13
	sublinear, the company starts to slow - 14
	superlinear, cooking example - 16

processes are slow to fork() and context switch - 19

threads introduction - 20
	example - 22
	rationale for threads - 25
		the real world is concurrent - 25
		threading is more responsive - 28
		threading makes for faster execution - 28
		no need for IPC - 29

	example of multi-threaded applications - 30
		web server - 30
				*ehm_loud.mp3* - 33
		array computation - 33
			parallel computation is not possible by forking - 36

	thread characteristics - 38
		execution context - 38
		process environment - 39
		address space - 41
			threads share heap and global vars but not stack - 41
		TCB thread control block, PCB process control block - 46

		differences between threads and processes - 48
wvwvwvwvwvwvwvwwvwvwvwvw Concurrency and Threads 1 wvwvwvwvwvwvwvwwvwvwvwvw

wvwvwvwvwvwvwvwwvwvwvwvw Concurrency and Threads 2 wvwvwvwvwvwvwvwwvwvwvwvw
previous lecture recap - 0
	concurrent definition, sequential definition - 0
	concurrency isnt parallelism - 1
	threads vs processes - 3

thread implementation - 4
	thread API - 4

	kernel level threads / one to one model - 8
		non-multi-threaded example - 9
		mutlithreaded example - 11
		context switching procedure - 12
	user level threads / many to one model - 14
		thread library - 14
		multi-threading example - 15
		context switching procedure - 16
			"but if one thread blocks on IO..." - 19
	direct comparison between kernel level threads and user level threads - 20
		go vs java - 23

wvwvwvwvwvwvwvwwvwvwvwvw Concurrency and Threads 2 wvwvwvwvwvwvwvwwvwvwvwvw

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX PROCESS MANAGEMENT XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX













================================================================================================================================
================================ OS OVERVIEW ===================================================================================
================================================================================================================================

+=+=+=+=+=+=+=+= OS Introduction +=+=+=+=+=+=+=+=

+=+=+=+=+=+=+=+= OS Introduction +=+=+=+=+=+=+=+=

================================================================================================================================
================================================================================================================================

================================================================================================================================
================================ OS OVERVIEW ===================================================================================
================================================================================================================================

